// This file was GENERATED by command:
//     pump.py clbind_functoids.pmp
// DO NOT EDIT BY HAND!!!

// ret = 0
// template_ = 0
// numVoids = 0
// numArgs = 16
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 16 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14) ,  frame::Value(frameImpl,15)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14,  core::T_sp arg15 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
translate::from_object<ARG13,typename DoesNotContain_<Pols,pureOutValue<14> >::type > a13(arg13);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<14> >::type >::go(args);
translate::from_object<ARG14,typename DoesNotContain_<Pols,pureOutValue<15> >::type > a14(arg14);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<15> >::type >::go(args);
translate::from_object<ARG15,typename DoesNotContain_<Pols,pureOutValue<16> >::type > a15(arg15);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<16> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,13>::type()
, typename AdoptPointer<Pols,13>::type()
, a13._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,14>::type()
, typename AdoptPointer<Pols,14>::type()
, a14._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,15>::type()
, typename AdoptPointer<Pols,15>::type()
, a15._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 1
// numVoids = 1
// numArgs = 15
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 15 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
translate::from_object<ARG13,typename DoesNotContain_<Pols,pureOutValue<14> >::type > a13(arg13);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<14> >::type >::go(args);
translate::from_object<ARG14,typename DoesNotContain_<Pols,pureOutValue<15> >::type > a14(arg14);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<15> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,13>::type()
, typename AdoptPointer<Pols,13>::type()
, a13._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,14>::type()
, typename AdoptPointer<Pols,14>::type()
, a14._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 2
// numVoids = 2
// numArgs = 14
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 14 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
translate::from_object<ARG13,typename DoesNotContain_<Pols,pureOutValue<14> >::type > a13(arg13);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<14> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,13>::type()
, typename AdoptPointer<Pols,13>::type()
, a13._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 3
// numVoids = 3
// numArgs = 13
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 13 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,
    core::T_sp arg12 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 4
// numVoids = 4
// numArgs = 12
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 12 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 5
// numVoids = 5
// numArgs = 11
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 11 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 6
// numVoids = 6
// numArgs = 10
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 10 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 7
// numVoids = 7
// numArgs = 9
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 9 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 8
// numVoids = 8
// numArgs = 8
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 8 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 9
// numVoids = 9
// numArgs = 7
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 7 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 10
// numVoids = 10
// numArgs = 6
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 6 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 11
// numVoids = 11
// numArgs = 5
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3, ARG4), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 5 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 12
// numVoids = 12
// numArgs = 4
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2, ARG3), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2, ARG3);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 4 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 13
// numVoids = 13
// numArgs = 3
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1,typename ARG2 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1, ARG2), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1, ARG2);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 3 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 14
// numVoids = 14
// numArgs = 2
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0,typename ARG1 >
class VariadicFunctoid
<  RT  (*)(ARG0, ARG1), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0, ARG1);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 2 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
RT retval =  fptr(a0._v,a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 15
// numVoids = 15
// numArgs = 1
/* Specialization */
template <typename Pols , typename RT  ,typename ARG0 >
class VariadicFunctoid
<  RT  (*)(ARG0), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)(ARG0);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 1 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
RT retval =  fptr(a0._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 0
// template_ = 16
// numVoids = 16
// numArgs = 0
/* Specialization */
template <typename Pols , typename RT   >
class VariadicFunctoid
<  RT  (*)(), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef RT(*Type)();
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 0 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
return this->invoke( );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  )
{
RT retval =  fptr();
int oidx = 1;
return gctools::multiple_values<core::T_O>(translate::to_object<RT,typename AdoptPointer<Pols,result>::type >::convert(retval),
    oidx);
}
};
// ret = 1
// template_ = 0
// numVoids = 0
// numArgs = 16
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 16 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14) ,  frame::Value(frameImpl,15)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14,  core::T_sp arg15 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
translate::from_object<ARG13,typename DoesNotContain_<Pols,pureOutValue<14> >::type > a13(arg13);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<14> >::type >::go(args);
translate::from_object<ARG14,typename DoesNotContain_<Pols,pureOutValue<15> >::type > a14(arg14);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<15> >::type >::go(args);
translate::from_object<ARG15,typename DoesNotContain_<Pols,pureOutValue<16> >::type > a15(arg15);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<16> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,13>::type()
, typename AdoptPointer<Pols,13>::type()
, a13._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,14>::type()
, typename AdoptPointer<Pols,14>::type()
, a14._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,15>::type()
, typename AdoptPointer<Pols,15>::type()
, a15._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 1
// numVoids = 1
// numArgs = 15
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 15 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
translate::from_object<ARG13,typename DoesNotContain_<Pols,pureOutValue<14> >::type > a13(arg13);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<14> >::type >::go(args);
translate::from_object<ARG14,typename DoesNotContain_<Pols,pureOutValue<15> >::type > a14(arg14);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<15> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,13>::type()
, typename AdoptPointer<Pols,13>::type()
, a13._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,14>::type()
, typename AdoptPointer<Pols,14>::type()
, a14._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 2
// numVoids = 2
// numArgs = 14
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 14 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
translate::from_object<ARG13,typename DoesNotContain_<Pols,pureOutValue<14> >::type > a13(arg13);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<14> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,13>::type()
, typename AdoptPointer<Pols,13>::type()
, a13._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 3
// numVoids = 3
// numArgs = 13
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 13 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,
    core::T_sp arg12 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 4
// numVoids = 4
// numArgs = 12
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 12 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 5
// numVoids = 5
// numArgs = 11
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 11 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 6
// numVoids = 6
// numArgs = 10
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 10 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 7
// numVoids = 7
// numArgs = 9
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 9 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 8
// numVoids = 8
// numArgs = 8
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 8 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 9
// numVoids = 9
// numArgs = 7
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 7 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 10
// numVoids = 10
// numArgs = 6
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 6 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 11
// numVoids = 11
// numArgs = 5
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3, ARG4), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3, ARG4);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 5 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 12
// numVoids = 12
// numArgs = 4
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2, ARG3), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2, ARG3);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 4 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
fptr(a0._v,a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 13
// numVoids = 13
// numArgs = 3
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1,typename ARG2 >
class VariadicFunctoid
< void (*)(ARG0, ARG1, ARG2), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1, ARG2);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 3 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
fptr(a0._v,a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 14
// numVoids = 14
// numArgs = 2
/* Specialization */
template <typename Pols  ,typename ARG0,typename ARG1 >
class VariadicFunctoid
< void (*)(ARG0, ARG1), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0, ARG1);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 2 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
fptr(a0._v,a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 15
// numVoids = 15
// numArgs = 1
/* Specialization */
template <typename Pols  ,typename ARG0 >
class VariadicFunctoid
< void (*)(ARG0), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)(ARG0);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 1 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
fptr(a0._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 0;                                                                     ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
return gctools::multiple_values<core::T_O>(returnValues.valueGet(0,oidx),oidx);
}
};
// ret = 1
// template_ = 16
// numVoids = 16
// numArgs = 0
/* Specialization */
template <typename Pols   >
class VariadicFunctoid
< void (*)(), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef void(*Type)();
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 0 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
return this->invoke( );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  )
{
fptr();
return Values0<core::T_O>();
}
};
// ret = 2
// template_ = 0
// numVoids = 0
// numArgs = 16
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14, ARG15);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 16 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14) ,  frame::Value(frameImpl,15)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14,  core::T_sp arg15 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
translate::from_object<ARG13,typename DoesNotContain_<Pols,pureOutValue<14> >::type > a13(arg13);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<14> >::type >::go(args);
translate::from_object<ARG14,typename DoesNotContain_<Pols,pureOutValue<15> >::type > a14(arg14);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<15> >::type >::go(args);
translate::from_object<ARG15,typename DoesNotContain_<Pols,pureOutValue<16> >::type > a15(arg15);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<16> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,
    a14._v,a15._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,13>::type()
, typename AdoptPointer<Pols,13>::type()
, a13._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,14>::type()
, typename AdoptPointer<Pols,14>::type()
, a14._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,15>::type()
, typename AdoptPointer<Pols,15>::type()
, a15._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 1
// numVoids = 1
// numArgs = 15
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 15 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
translate::from_object<ARG13,typename DoesNotContain_<Pols,pureOutValue<14> >::type > a13(arg13);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<14> >::type >::go(args);
translate::from_object<ARG14,typename DoesNotContain_<Pols,pureOutValue<15> >::type > a14(arg14);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<15> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,
    a14._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,13>::type()
, typename AdoptPointer<Pols,13>::type()
, a13._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,14>::type()
, typename AdoptPointer<Pols,14>::type()
, a14._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 2
// numVoids = 2
// numArgs = 14
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 14 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
translate::from_object<ARG13,typename DoesNotContain_<Pols,pureOutValue<14> >::type > a13(arg13);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<14> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,13>::type()
, typename AdoptPointer<Pols,13>::type()
, a13._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 3
// numVoids = 3
// numArgs = 13
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 13 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11) ,
    frame::Value(frameImpl,12)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,
    core::T_sp arg12 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
translate::from_object<ARG12,typename DoesNotContain_<Pols,pureOutValue<13> >::type > a12(arg12);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<13> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,12>::type()
, typename AdoptPointer<Pols,12>::type()
, a12._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 4
// numVoids = 4
// numArgs = 12
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 12 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,  frame::Value(frameImpl,11)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
translate::from_object<ARG11,typename DoesNotContain_<Pols,pureOutValue<12> >::type > a11(arg11);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<12> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,11>::type()
, typename AdoptPointer<Pols,11>::type()
, a11._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 5
// numVoids = 5
// numArgs = 11
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 11 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
translate::from_object<ARG10,typename DoesNotContain_<Pols,pureOutValue<11> >::type > a10(arg10);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<11> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,10>::type()
, typename AdoptPointer<Pols,10>::type()
, a10._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 6
// numVoids = 6
// numArgs = 10
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 10 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
translate::from_object<ARG9,typename DoesNotContain_<Pols,pureOutValue<10> >::type > a9(arg9);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<10> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,9>::type()
, typename AdoptPointer<Pols,9>::type()
, a9._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 7
// numVoids = 7
// numArgs = 9
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 9 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7) ,
    frame::Value(frameImpl,8)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
translate::from_object<ARG8,typename DoesNotContain_<Pols,pureOutValue<9> >::type > a8(arg8);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<9> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,8>::type()
, typename AdoptPointer<Pols,8>::type()
, a8._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 8
// numVoids = 8
// numArgs = 8
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 8 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,  frame::Value(frameImpl,7)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
translate::from_object<ARG7,typename DoesNotContain_<Pols,pureOutValue<8> >::type > a7(arg7);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<8> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,7>::type()
, typename AdoptPointer<Pols,7>::type()
, a7._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 9
// numVoids = 9
// numArgs = 7
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 7 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
translate::from_object<ARG6,typename DoesNotContain_<Pols,pureOutValue<7> >::type > a6(arg6);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<7> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,6>::type()
, typename AdoptPointer<Pols,6>::type()
, a6._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 10
// numVoids = 10
// numArgs = 6
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 6 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
translate::from_object<ARG5,typename DoesNotContain_<Pols,pureOutValue<6> >::type > a5(arg5);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<6> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,5>::type()
, typename AdoptPointer<Pols,5>::type()
, a5._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 11
// numVoids = 11
// numArgs = 5
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3, ARG4), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3, ARG4);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 5 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3) ,  frame::Value(frameImpl,4)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
translate::from_object<ARG4,typename DoesNotContain_<Pols,pureOutValue<5> >::type > a4(arg4);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<5> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,4>::type()
, typename AdoptPointer<Pols,4>::type()
, a4._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 12
// numVoids = 12
// numArgs = 4
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2,typename ARG3 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2, ARG3), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2, ARG3);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 4 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,  frame::Value(frameImpl,
    3)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
translate::from_object<ARG3,typename DoesNotContain_<Pols,pureOutValue<4> >::type > a3(arg3);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<4> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v,a3._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,3>::type()
, typename AdoptPointer<Pols,3>::type()
, a3._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 13
// numVoids = 13
// numArgs = 3
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1,typename ARG2 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1, ARG2), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1, ARG2);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 3 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
translate::from_object<ARG2,typename DoesNotContain_<Pols,pureOutValue<3> >::type > a2(arg2);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<3> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v,a2._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,2>::type()
, typename AdoptPointer<Pols,2>::type()
, a2._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 14
// numVoids = 14
// numArgs = 2
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0,typename ARG1 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0, ARG1), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0, ARG1);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 2 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0,  core::T_sp arg1 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
translate::from_object<ARG1,typename DoesNotContain_<Pols,pureOutValue<2> >::type > a1(arg1);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<2> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v,a1._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,1>::type()
, typename AdoptPointer<Pols,1>::type()
, a1._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 15
// numVoids = 15
// numArgs = 1
/* Specialization */
template <typename Pols , typename UPRT  ,typename ARG0 >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(ARG0), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)(ARG0);
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 1 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke( frame::Value(frameImpl,0)  );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  core::T_sp arg0 )
{
translate::from_object<ARG0,typename DoesNotContain_<Pols,pureOutValue<1> >::type > a0(arg0);
//IncWhen<typename DoesNotContain_<Pols,pureOutValue<1> >::type >::go(args);
std::unique_ptr<UPRT> retval =  fptr(a0._v);
core::MultipleValues& returnValues = core::lisp_multipleValues();
returnValues.setSize(0);
int oidx = 1;
ReturnValueWhen(returnValues,oidx
, typename is_outValue<Pols,0>::type()
, typename AdoptPointer<Pols,0>::type()
, a0._v);
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};
// ret = 2
// template_ = 16
// numVoids = 16
// numArgs = 0
/* Specialization */
template <typename Pols , typename UPRT   >
class VariadicFunctoid
<  std::unique_ptr<UPRT>  (*)(), Pols>
: public core::BuiltinClosure {
public:
typedef core::BuiltinClosure TemplatedBase;
public:
typedef  std::unique_ptr<UPRT> (*Type)();
Type fptr;
public:
virtual const char* describe() const { return "VariadicFunctoid"; };
enum { NumParams = 0 };
VariadicFunctoid(core::T_sp name, Type ptr) : core::BuiltinClosure(name), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
return this->invoke( );
};
// I need a 1:1 match between the arguments passed to invoke and those passed to the wrapped function because
// I can't iterate through the required arguments because I don't use varargs
LCC_RETURN invoke(  )
{
std::unique_ptr<UPRT> retval =  fptr();
int oidx = 1;
return gctools::multiple_values<core::T_O>(translate::to_object<std::unique_ptr<UPRT>, typename AdoptPointer<Pols,
    result>::type>::convert(std::move(retval)),oidx);
}
};

