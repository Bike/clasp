// This file was GENERATED by command:
//     pump.py wrappers_functoids.pmp
// DO NOT EDIT BY HAND!!!


// ret = 0  RetSV
// numArgs = 16
// numVoids = 0
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15);
Type fptr;
public:
enum { NumParams = 16 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14) ,
    frame::Value(frameImpl,15)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14,  core::T_sp arg15 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 15
// numVoids = 1
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14);
Type fptr;
public:
enum { NumParams = 15 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 14
// numVoids = 2
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13);
Type fptr;
public:
enum { NumParams = 14 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 13
// numVoids = 3
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);
Type fptr;
public:
enum { NumParams = 13 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,
    core::T_sp arg12 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 12
// numVoids = 4
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11);
Type fptr;
public:
enum { NumParams = 12 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 11
// numVoids = 5
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10);
Type fptr;
public:
enum { NumParams = 11 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 10
// numVoids = 6
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);
Type fptr;
public:
enum { NumParams = 10 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 9
// numVoids = 7
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8);
Type fptr;
public:
enum { NumParams = 9 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 8
// numVoids = 8
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
Type fptr;
public:
enum { NumParams = 8 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 7
// numVoids = 9
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
Type fptr;
public:
enum { NumParams = 7 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 6
// numVoids = 10
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5);
Type fptr;
public:
enum { NumParams = 6 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 5
// numVoids = 11
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3, ARG4) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4);
Type fptr;
public:
enum { NumParams = 5 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 4
// numVoids = 12
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2, ARG3) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2, ARG3);
Type fptr;
public:
enum { NumParams = 4 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
RT retval =  fptr(a0._v,a1._v,a2._v,a3._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 3
// numVoids = 13
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2 >
class VariadicFunctoid
<RT (ARG0, ARG1, ARG2) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1, ARG2);
Type fptr;
public:
enum { NumParams = 3 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
RT retval =  fptr(a0._v,a1._v,a2._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 2
// numVoids = 14
/* Specialization */
template <typename RT , typename ARG0,typename ARG1 >
class VariadicFunctoid
<RT (ARG0, ARG1) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0, ARG1);
Type fptr;
public:
enum { NumParams = 2 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
RT retval =  fptr(a0._v,a1._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 1
// numVoids = 15
/* Specialization */
template <typename RT , typename ARG0 >
class VariadicFunctoid
<RT (ARG0) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) (ARG0);
Type fptr;
public:
enum { NumParams = 1 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0)  );
}

LCC_RETURN invoke( core::T_sp arg0 )
{
translate::from_object<ARG0> a0(arg0);
RT retval =  fptr(a0._v);
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 0  RetSV
// numArgs = 0
// numVoids = 16
/* Specialization */
template <typename RT   >
class VariadicFunctoid
<RT () >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef RT(*Type) ();
Type fptr;
public:
enum { NumParams = 0 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
return this->invoke(  );
}

LCC_RETURN invoke( )
{
RT retval =  fptr();
return Values(translate::to_object<RT>::convert(retval));
}

};
// ret = 1  RetVoid
// numArgs = 16
// numVoids = 0
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,typename ARG15 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15);
Type fptr;
public:
enum { NumParams = 16 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14) ,
    frame::Value(frameImpl,15)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14,  core::T_sp arg15 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 15
// numVoids = 1
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14);
Type fptr;
public:
enum { NumParams = 15 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 14
// numVoids = 2
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13);
Type fptr;
public:
enum { NumParams = 14 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 13
// numVoids = 3
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);
Type fptr;
public:
enum { NumParams = 13 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,
    core::T_sp arg12 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 12
// numVoids = 4
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11);
Type fptr;
public:
enum { NumParams = 12 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 11
// numVoids = 5
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9,typename ARG10 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10);
Type fptr;
public:
enum { NumParams = 11 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 10
// numVoids = 6
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8,typename ARG9 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);
Type fptr;
public:
enum { NumParams = 10 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 9
// numVoids = 7
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7,
    typename ARG8 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8);
Type fptr;
public:
enum { NumParams = 9 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 8
// numVoids = 8
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,typename ARG7 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
Type fptr;
public:
enum { NumParams = 8 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 7
// numVoids = 9
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
Type fptr;
public:
enum { NumParams = 7 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 6
// numVoids = 10
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5);
Type fptr;
public:
enum { NumParams = 6 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 5
// numVoids = 11
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3, ARG4) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4);
Type fptr;
public:
enum { NumParams = 5 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
fptr(a0._v,a1._v,a2._v,a3._v,a4._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 4
// numVoids = 12
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2,typename ARG3 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2, ARG3) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2, ARG3);
Type fptr;
public:
enum { NumParams = 4 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
fptr(a0._v,a1._v,a2._v,a3._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 3
// numVoids = 13
/* Specialization */
template < typename ARG0,typename ARG1,typename ARG2 >
class VariadicFunctoid
<void(ARG0, ARG1, ARG2) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1, ARG2);
Type fptr;
public:
enum { NumParams = 3 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
fptr(a0._v,a1._v,a2._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 2
// numVoids = 14
/* Specialization */
template < typename ARG0,typename ARG1 >
class VariadicFunctoid
<void(ARG0, ARG1) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0, ARG1);
Type fptr;
public:
enum { NumParams = 2 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
fptr(a0._v,a1._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 1
// numVoids = 15
/* Specialization */
template < typename ARG0 >
class VariadicFunctoid
<void(ARG0) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) (ARG0);
Type fptr;
public:
enum { NumParams = 1 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0)  );
}

LCC_RETURN invoke( core::T_sp arg0 )
{
translate::from_object<ARG0> a0(arg0);
fptr(a0._v);
return Values0<core::T_O>();
}

};
// ret = 1  RetVoid
// numArgs = 0
// numVoids = 16
/* Specialization */
template <  >
class VariadicFunctoid
<void() >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef void(*Type) ();
Type fptr;
public:
enum { NumParams = 0 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
return this->invoke(  );
}

LCC_RETURN invoke( )
{
fptr();
return Values0<core::T_O>();
}

};
// ret = 2  RetMV
// numArgs = 16
// numVoids = 0
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14,
    ARG15) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13, ARG14, ARG15);
Type fptr;
public:
enum { NumParams = 16 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14) ,
    frame::Value(frameImpl,15)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14,  core::T_sp arg15 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v,a15._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 15
// numVoids = 1
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13, ARG14);
Type fptr;
public:
enum { NumParams = 15 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13) ,  frame::Value(frameImpl,14)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13,  core::T_sp arg14 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v,a14._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 14
// numVoids = 2
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13);
Type fptr;
public:
enum { NumParams = 14 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12) ,  frame::Value(frameImpl,13)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,  core::T_sp arg12,
    core::T_sp arg13 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,
    a13._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 13
// numVoids = 3
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12);
Type fptr;
public:
enum { NumParams = 13 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) ,  frame::Value(frameImpl,12)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11,
    core::T_sp arg12 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 12
// numVoids = 4
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11);
Type fptr;
public:
enum { NumParams = 12 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10,  core::T_sp arg11 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 11
// numVoids = 5
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10);
Type fptr;
public:
enum { NumParams = 11 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9) ,  frame::Value(frameImpl,10)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9,  core::T_sp arg10 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 10
// numVoids = 6
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9);
Type fptr;
public:
enum { NumParams = 10 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8) ,  frame::Value(frameImpl,9)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8,  core::T_sp arg9 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 9
// numVoids = 7
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8);
Type fptr;
public:
enum { NumParams = 9 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) ,  frame::Value(frameImpl,8)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7,  core::T_sp arg8 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 8
// numVoids = 8
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
Type fptr;
public:
enum { NumParams = 8 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6,  core::T_sp arg7 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 7
// numVoids = 9
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
Type fptr;
public:
enum { NumParams = 7 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5) ,  frame::Value(frameImpl,6)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5,
    core::T_sp arg6 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 6
// numVoids = 10
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4, ARG5) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4, ARG5);
Type fptr;
public:
enum { NumParams = 6 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4) ,  frame::Value(frameImpl,5)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4,  core::T_sp arg5 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v,a5._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 5
// numVoids = 11
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3, ARG4) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3, ARG4);
Type fptr;
public:
enum { NumParams = 5 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) ,  frame::Value(frameImpl,4)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3,  core::T_sp arg4 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v,a4._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 4
// numVoids = 12
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2,typename ARG3 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2, ARG3) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2, ARG3);
Type fptr;
public:
enum { NumParams = 4 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2,  core::T_sp arg3 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v,a3._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 3
// numVoids = 13
/* Specialization */
template <typename RT , typename ARG0,typename ARG1,typename ARG2 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1, ARG2) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1, ARG2);
Type fptr;
public:
enum { NumParams = 3 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1) ,  frame::Value(frameImpl,2)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1,  core::T_sp arg2 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v,a2._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 2
// numVoids = 14
/* Specialization */
template <typename RT , typename ARG0,typename ARG1 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0, ARG1) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0, ARG1);
Type fptr;
public:
enum { NumParams = 2 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0) ,  frame::Value(frameImpl,1)  );
}

LCC_RETURN invoke( core::T_sp arg0,  core::T_sp arg1 )
{
translate::from_object<ARG0> a0(arg0);
translate::from_object<ARG1> a1(arg1);
gctools::multiple_values<RT> retval =  fptr(a0._v,a1._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 1
// numVoids = 15
/* Specialization */
template <typename RT , typename ARG0 >
class VariadicFunctoid
<gctools::multiple_values<RT>(ARG0) >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) (ARG0);
Type fptr;
public:
enum { NumParams = 1 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
return this->invoke(  frame::Value(frameImpl,0)  );
}

LCC_RETURN invoke( core::T_sp arg0 )
{
translate::from_object<ARG0> a0(arg0);
gctools::multiple_values<RT> retval =  fptr(a0._v);
return retval;
}

};
// ret = 2  RetMV
// numArgs = 0
// numVoids = 16
/* Specialization */
template <typename RT   >
class VariadicFunctoid
<gctools::multiple_values<RT>() >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicFunctoid";};

typedef gctools::multiple_values<RT>(*Type) ();
Type fptr;
public:
enum { NumParams = 0 };
VariadicFunctoid(T_sp name, T_sp spi, Symbol_sp funcType, Type ptr) : BuiltinClosure(name,spi,funcType), fptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this); };
virtual void* functionAddress() const { return (void*)this->fptr; };
LCC_RETURN LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
return this->invoke(  );
}

LCC_RETURN invoke( )
{
gctools::multiple_values<RT> retval =  fptr();
return retval;
}

};



