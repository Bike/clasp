// This file was GENERATED by command:
//     pump.py wrappers_methoids.pmp
// DO NOT EDIT BY HAND!!!

//
// Methods
//
// Three kinds of return values    single-value, multiple-value and void                              //
// ret = 0  RetSV
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) ,
    frame::Value(frameImpl,15)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
RT retval =  ((*ot.get()).*mptr)(a1._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn ,typename RT, typename OT  >
class VariadicMethoid
<DispatchOn,RT (OT::*)( )  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)() ;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
RT retval =  ((*ot.get()).*mptr)();
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) ,
    frame::Value(frameImpl,15)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
((*ot.get()).*mptr)(a1._v,a2._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
((*ot.get()).*mptr)(a1._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn , typename OT  >
class VariadicMethoid
<DispatchOn,void (OT::*)( )  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)() ;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
((*ot.get()).*mptr)();
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14, ARG15)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14, ARG15) ;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) ,
    frame::Value(frameImpl,15)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v,a14._v,a15._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) ;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v,a14._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) ;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) ;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) ;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) ;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) ;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) ;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) ;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) ;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) ;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4) ;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3) ;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2) ;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1)  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1) ;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn ,typename RT, typename OT  >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( )  >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)() ;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)();
*lcc_resultP = retval;
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) ,
    frame::Value(frameImpl,15)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1, ARG2) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
RT retval =  ((*ot.get()).*mptr)(a1._v,a2._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ARG1) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)(ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
RT retval =  ((*ot.get()).*mptr)(a1._v);
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 0  RetSV
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn ,typename RT, typename OT  >
class VariadicMethoid
<DispatchOn,RT (OT::*)( ) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef RT(OT::*Type)() const;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
RT retval =  ((*ot.get()).*mptr)();
*lcc_resultP = Values(translate::to_object<RT>::convert(retval));
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14,
    typename ARG15 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14, ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) ,
    frame::Value(frameImpl,15)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v,a15._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,typename ARG14 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13, ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v,a14._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v,a13._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,a12._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6,
    typename ARG7 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,typename ARG6 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
((*ot.get()).*mptr)(a1._v,a2._v,a3._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1, ARG2) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
((*ot.get()).*mptr)(a1._v,a2._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn , typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,void (OT::*)( ARG1) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)(ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
((*ot.get()).*mptr)(a1._v);
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 1  RetVoid
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn , typename OT  >
class VariadicMethoid
<DispatchOn,void (OT::*)( ) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef void(OT::*Type)() const;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
((*ot.get()).*mptr)();
*lcc_resultP = Values0<core::T_O>();
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 16
// numVoids = 0
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14,typename ARG15 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14, ARG15) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14, ARG15) const;
Type mptr;
public:
enum { NumParams = 16 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,16);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14) ,
    frame::Value(frameImpl,15)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14, core::T_sp arg15 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
translate::from_object<ARG15> a15(arg15);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v,a14._v,a15._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 15
// numVoids = 1
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13,
    typename ARG14 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12, ARG13,
    ARG14) const;
Type mptr;
public:
enum { NumParams = 15 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,15);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13) , frame::Value(frameImpl,14)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13, core::T_sp arg14 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
translate::from_object<ARG14> a14(arg14);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v,a14._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 14
// numVoids = 2
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12,typename ARG13 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12,
    ARG13) const;
Type mptr;
public:
enum { NumParams = 14 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,14);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12) , frame::Value(frameImpl,13)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12, core::T_sp arg13 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
translate::from_object<ARG13> a13(arg13);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v,a13._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 13
// numVoids = 3
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11,typename ARG12 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11, ARG12) const;
Type mptr;
public:
enum { NumParams = 13 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,13);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11) , frame::Value(frameImpl,12)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11,
    core::T_sp arg12 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
translate::from_object<ARG12> a12(arg12);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v,
    a12._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 12
// numVoids = 4
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10,typename ARG11 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10, ARG11) const;
Type mptr;
public:
enum { NumParams = 12 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,12);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10) ,
    frame::Value(frameImpl,11)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10, core::T_sp arg11 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
translate::from_object<ARG11> a11(arg11);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v,a11._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 11
// numVoids = 5
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9,typename ARG10 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9, ARG10) const;
Type mptr;
public:
enum { NumParams = 11 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,11);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9) , frame::Value(frameImpl,10)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9, core::T_sp arg10 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
translate::from_object<ARG10> a10(arg10);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v,a10._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 10
// numVoids = 6
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8,typename ARG9 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8, ARG9) const;
Type mptr;
public:
enum { NumParams = 10 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,10);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8) , frame::Value(frameImpl,9)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8, core::T_sp arg9 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
translate::from_object<ARG9> a9(arg9);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v,a9._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 9
// numVoids = 7
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7,typename ARG8 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8) const;
Type mptr;
public:
enum { NumParams = 9 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,9);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7) , frame::Value(frameImpl,8)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7, core::T_sp arg8 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
translate::from_object<ARG8> a8(arg8);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v,a8._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 8
// numVoids = 8
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6,typename ARG7 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) const;
Type mptr;
public:
enum { NumParams = 8 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,8);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6) ,
    frame::Value(frameImpl,7)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6, core::T_sp arg7 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
translate::from_object<ARG7> a7(arg7);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v,a7._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 7
// numVoids = 9
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5,
    typename ARG6 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) const;
Type mptr;
public:
enum { NumParams = 7 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,7);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5) , frame::Value(frameImpl,6)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5, core::T_sp arg6 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
translate::from_object<ARG6> a6(arg6);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v,a6._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 6
// numVoids = 10
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4,typename ARG5 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4, ARG5) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4, ARG5) const;
Type mptr;
public:
enum { NumParams = 6 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,6);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4) , frame::Value(frameImpl,5)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4,
    core::T_sp arg5 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
translate::from_object<ARG5> a5(arg5);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v,a5._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 5
// numVoids = 11
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3,typename ARG4 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3, ARG4) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3, ARG4) const;
Type mptr;
public:
enum { NumParams = 5 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,5);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3) , frame::Value(frameImpl,4)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3, core::T_sp arg4 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
translate::from_object<ARG4> a4(arg4);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v,a4._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 4
// numVoids = 12
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2,typename ARG3 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2, ARG3) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2, ARG3) const;
Type mptr;
public:
enum { NumParams = 4 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,4);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2) ,
    frame::Value(frameImpl,3)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2, core::T_sp arg3 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
translate::from_object<ARG3> a3(arg3);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v,a3._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 3
// numVoids = 13
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1,typename ARG2 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1, ARG2) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1, ARG2) const;
Type mptr;
public:
enum { NumParams = 3 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,3);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1) , frame::Value(frameImpl,2)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1, core::T_sp arg2 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
translate::from_object<ARG2> a2(arg2);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v,a2._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 2
// numVoids = 14
/* Specialization */
template <int DispatchOn ,typename RT, typename OT ,typename ARG1 >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ARG1) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)(ARG1) const;
Type mptr;
public:
enum { NumParams = 2 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,2);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0) , frame::Value(frameImpl,1)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0  , core::T_sp arg1 )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
translate::from_object<ARG1> a1(arg1);
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)(a1._v);
*lcc_resultP = retval;
}
};
//
// ret = 2  RetMV
//
//
// numArgs = 1
// numVoids = 15
/* Specialization */
template <int DispatchOn ,typename RT, typename OT  >
class VariadicMethoid
<DispatchOn,gctools::multiple_values<RT> (OT::*)( ) const >
: public BuiltinClosure {
public:
typedef BuiltinClosure TemplatedBase;
public:
virtual const char* describe() const {return "VariadicMethoid";};
typedef gctools::multiple_values<RT>(OT::*Type)() const;
Type mptr;
public:
enum { NumParams = 1 };
VariadicMethoid(T_sp name, Type ptr) : BuiltinClosure(name), mptr(ptr) {};
DISABLE_NEW();
virtual size_t templatedSizeof() const { return sizeof(*this);};
void LISP_CALLING_CONVENTION()
{
INVOCATION_HISTORY_FRAME();
ALLOC_STACK_VALUE_FRAME(frameImpl,frame,1);
core::StackFrameDynamicScopeManager scope(frame);
lambdaListHandler_createBindings(this,this->_lambdaListHandler,scope,LCC_PASS_ARGS);
this->invoke(lcc_resultP, frame::Value(frameImpl,0)  );
}

void invoke(core::T_mv* lcc_resultP, core::T_sp arg0   )
{
gctools::smart_ptr<OT> ot((arg0).template as<OT>());
gctools::multiple_values<RT> retval =  ((*ot.get()).*mptr)();
*lcc_resultP = retval;
}
};

