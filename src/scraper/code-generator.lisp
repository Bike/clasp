(in-package :cscrape)

(define-condition bad-c++-name (error)
  ((name :initarg :name :accessor name))
  (:report (lambda (condition stream)
             (format stream "Bad C++ function name: ~a" (name condition)))))

(defun group-expose-functions-by-namespace (tags)
  (declare (optimize (debug 3)))
  (let ((ns-hashes (make-hash-table :test #'equal))
        current-namespace)
    (dolist (tag tags)
      (cond
        ((typep tag 'tags:namespace-tag)
         (setq current-namespace (tags:namespace tag)))
        ((typep tag 'tags:expose-function-tag)
         (or current-namespace (error "There must be a current namespace defined"))
         (let ((ns-ht (gethash current-namespace ns-hashes (make-hash-table :test #'equal))))
           (setf (gethash (tags:function-name tag) ns-ht) tag)
           (setf (gethash current-namespace ns-hashes) ns-ht)))
        (t #|nothing|#)))
    ns-hashes))



(defun generate-expose-function-signatures (sout ns-grouped-expose-functions)
  (format sout "#ifdef EXPOSE_FUNCTION_SIGNATURES~%")
  (maphash (lambda (ns func-ht)
             (format sout "namespace ~a {~%" ns)
             (maphash (lambda (name f)
                        (declare (ignore name))
                        (format sout "    ~a;~%" (tags:signature-text f)))
                      func-ht)
             (format sout "};~%"))
           ns-grouped-expose-functions)
  (format sout "#endif // EXPOSE_FUNCTION_SIGNATURES~%"))


(defun split-c++-name (name)
  (declare (optimize (debug 3)))
  (let ((under (search "__" name :test #'string=)))
    (unless under
      (error 'bad-c++-name :name name))
    (let* ((name-pos (+ 2 under)))
      (values (subseq name 0 under)
              (subseq name name-pos)))))

(defun generate-expose-function-bindings (sout ns-grouped-expose-functions)
  (declare (optimize (debug 3)))
  (flet ((expose-one (f ns)
           (let* ((lambda-list-tag (tags:lambda-tag f))
                  (lambda-list-str (if lambda-list-tag
                                       (tags:lambda-list lambda-list-tag)
                                       nil)))
             (multiple-value-bind (pkg name)
                 (split-c++-name (tags:function-name f))
               (format sout "  expose_function(\"~a\",\"~a\",~a,&~a::~a,~s);~%"
                       pkg name
                       "true"
                       ns
                       (tags:function-name f)
                       (if lambda-list-str
                           (format nil "(~a)" lambda-list-str)
                           ""))))))
    (format sout "#ifdef EXPOSE_FUNCTION_BINDINGS~%")
    (maphash (lambda (ns funcs-ht)
               (maphash (lambda (name f)
                          (declare (ignore name))
                          (handler-case
                              (expose-one f ns)
                            (serious-condition (condition)
                              (error "There was an error while exposing a function in ~a at line ~d~%~a~%" (tags:file f) (tags:line f) condition))))
                        funcs-ht))
             ns-grouped-expose-functions)
    (format sout "#endif // EXPOSE_FUNCTION_BINDINGS~%")))


(defun extract-unique-source-info-tags (tags)
  (let ((unique-source-info (make-hash-table :test #'equal)))
    (dolist (tag tags)
      (cond
        ((typep tag 'tags:expose-function-tag)
         (setf (gethash (tags:function-name tag) unique-source-info) tag))
        (t #|nothing|#)))
    (let (source-info)
      (maphash (lambda (k v)
                 (declare (ignore k))
                 (push v source-info)) unique-source-info)
      source-info)))

(defun generate-expose-source-info (sout source-info-tags cppdefine)
  (format sout "#ifdef ~a~%" cppdefine)
  (dolist (f source-info-tags)
    (let* ((fn (tags:function-name f))
           (file (tags:file f))
           (line (tags:line f))
           (char-offset (tags:character-offset f))
           (docstring-tag (tags:docstring-tag f))
           (docstring (if docstring-tag
                          (tags:docstring docstring-tag)
                          "\"\"")))
      (multiple-value-bind (package-name symbol-name)
          (split-c++-name fn)
        (format sout "  { \"~a\", \"~a\", ~s, ~d, ~d, ~a }, ~%"
                package-name symbol-name file char-offset line docstring ))))
  (format sout "#endif // ~a~%" cppdefine))

(defun generate-tags-file (tags-file-name tags)
  (declare (optimize (debug 3)))
  (let* ((source-info-tags (extract-unique-source-info-tags tags))
         (file-ht (make-hash-table :test #'equal)))
    (dolist (tag source-info-tags)
      (push tag (gethash (tags:file tag) file-ht)))
    (let ((tags-data-ht (make-hash-table :test #'equal)))
      (maphash (lambda (file-name file-tags-list)
                 (let ((buffer (make-string-output-stream #+(or):element-type #+(or)'(unsigned-byte 8))))
                   (dolist (tag file-tags-list)
                     (format buffer "~a~a~a,~a~%"
                             (tags:function-name tag)
                             (code-char #x7f)
                             (tags:line tag)
                             (tags:character-offset tag)))
                   (setf (gethash file-name tags-data-ht) (get-output-stream-string buffer))))
               file-ht)
      (with-open-file (sout tags-file-name :direction :output #+(or):element-type #+(or)'(unsigned-byte 8)
                            :if-exists :supersede)
        (maphash (lambda (file buffer)
                   (format sout "~a,~a~%"
                           file
                           (length buffer))
                   (princ buffer sout))
                 tags-data-ht)))))

(defun generate-code-for-init-functions (tags)
  (declare (optimize (debug 3)))
  (with-output-to-string (sout)
    (let ((ns-grouped (group-expose-functions-by-namespace tags)))
      (generate-expose-function-signatures sout ns-grouped)
      (generate-expose-function-bindings sout ns-grouped))))

(defun inherits-from (x y inheritance)
    (let ((x-name (class-key-from-lisp-class-tag (class-tag x)))
          (y-name (class-key-from-lisp-class-tag (class-tag y)))
          ancestor)
      (loop
         (setf ancestor (gethash x-name inheritance))
         (unless ancestor
           (return-from inherits-from nil))
         (if (string= ancestor y-name)
             (return-from inherits-from t))
         (setf x-name ancestor))))

(defparameter *classes* nil)
(defparameter *inheritance* nil)
(defun sort-classes-by-inheritance (exposed-classes)
  (let ((inheritance (make-hash-table :test #'equal))
        (classes nil))
    (maphash (lambda (k v)
               (let ((base (tags::c++-base% (class-tag v))))
                 (when base (setf (gethash k inheritance) base))
                 (push v classes)))
             exposed-classes)
    (setf *classes* classes)
    (setf *inheritance* inheritance)
    (format t "About to sort classes~%")
    (sort classes (lambda (x y)
                    (inherits-from y x inheritance)))))


(defun generate-code-for-init-classes-and-methods (exposed-classes)
  (declare (optimize (debug 3)))
  (with-output-to-string (sout)
    (let ((sorted-classes (sort-classes-by-inheritance exposed-classes)))
      (format sout "#ifdef EXPOSE_CLASSES~%")
      (dolist (exposed-class sorted-classes)
        (let ((class-tag (class-tag exposed-class)))
          (format sout "DO_CLASS(~a,~a,~a,~a,~s);~%"
                  (tags:namespace% class-tag)
                  (tags:package% class-tag)
                  (tags:c++-base% class-tag)
                  (tags:c++-class% class-tag)
                  (tags:class-symbol% class-tag))))
      (format sout "#endif // EXPOSE_CLASSES~%")
      (format sout "#ifdef EXPOSE_METHODS~%")
      (dolist (exposed-class sorted-classes)
        (let ((class-tag (class-tag exposed-class)))
          (format sout "namespace ~a {~%" (tags:namespace% class-tag))
          (format sout "void ~a::expose_to_clasp() {~%" (tags:c++-class% class-tag))
          (format sout "    ~a<~a>()~%"
                  (if (eq (tags:kind% class-tag) :external-class)
                      "externalClass_"
                      "class_")
                  (tags:c++-class% class-tag))
          (dolist (method-tag (methods exposed-class))
            (let* ((name (tags:name (tags:name-tag method-tag)))
                   (class-name (tags:class-name% method-tag))
                   (method-name (tags:method-name method-tag))
                   (lambda-tag (tags:lambda-tag method-tag))
                   (lambda-list (if lambda-tag (tags:lambda-list lambda-tag) ""))
                   (declare-tag (tags:declare-tag method-tag))
                   (declare-form (if declare-tag (tags:declare-form declare-tag) ""))
                   (docstring-tag (tags:docstring-tag method-tag))
                   (docstring (if docstring-tag (tags:docstring docstring-tag) "")))
              (format sout "        .def(~s,&~a::~a,R\"lambda(~a)lambda\",R\"decl(~a)decl\",~a)~%"
                      name
                      class-name
                      method-name
                      lambda-list
                      declare-form
                      docstring)))
          (format sout "     ;~%")
          (format sout "}~%")
          (format sout "};~%")))
      (format sout "#endif // EXPOSE_METHODS~%"))))
          
(defun generate-code-for-source-info (tags)
  (with-output-to-string (sout)
    (let ((source-info-tags (extract-unique-source-info-tags tags)))
      (generate-expose-source-info sout source-info-tags "SOURCE_INFO"))))

(defparameter *unique-symbols* nil)
(defparameter *symbols-by-package* nil)
(defun generate-code-for-symbols (tags)
  (declare (optimize (debug 3)))
  ;; Uniqify the symbols
  (let ((unique-symbols (make-hash-table :test #'equal)))
    (setq *unique-symbols* unique-symbols)
    (dolist (tag tags)
      (cond
        ((typep tag 'tags:symbol-tag)
         (setf (gethash (list (tags:package% tag) (tags:name% tag) (tags:name% tag)) unique-symbols) tag))
        ;; classes generate symbols
        ((typep tag 'tags:lisp-class-tag)
         (setf (gethash (list (tags:package% tag) (tags:class-symbol% tag) (tags:c++-class% tag)) unique-symbols)
               (make-instance 'tags:symbol-tag
                              :package% (tags:package% tag)
                              :exported% t
                              :c++-name% (tags:c++-class% tag)
                              :name% (tags:class-symbol% tag)
                              :namespace% (tags:namespace% tag))))))
    (with-output-to-string (sout)
      (let ((symbols-by-package (make-hash-table :test #'equal))
            (index 0))
        (setq *symbols-by-package* symbols-by-package)
        ;; Organize symbols by package
        (maphash (lambda (key tag)
                   (declare (ignore key))
                   (when (typep tag 'tags:symbol-tag)
                     (push tag (gethash (tags:package% tag) symbols-by-package))))
                 unique-symbols)
        (maphash (lambda (package package-tags)
                   (format sout "#ifdef ~a_SYMBOLS~%" package)
                   (dolist (tag package-tags)
                     (format sout "DO_SYMBOL(_sym_~a,~d,~a,\"~a\",~a);~%"
                             (tags:c++-name% tag)
                             index
                             (tags:package% tag)
                             (tags:name% tag)
                             (if (tags:exported% tag)
                                 "true"
                                 "false"))
                     (incf index))
                   (format sout "#endif // ~a_SYMBOLS~%" package))
                 symbols-by-package)))))

(defun write-if-changed (code main-path app-relative)
  (let ((pn (make-pathname :name (pathname-name app-relative)
                           :type (pathname-type app-relative)
                           :directory '(:relative "include" "generated")
                           :defaults (pathname main-path))))
    (let ((data-in-file (when (probe-file pn)
                          (with-open-file (stream pn :direction :input)
                            (let ((data (make-string (file-length stream))))
                              (read-sequence data stream)
                              data)))))
      (unless (string= data-in-file code)
        (with-open-file (stream pn :direction :output :if-exists :supersede)
          (write-sequence code stream))))))

(defun generate-code (tags exposed-classes main-path app-config)
  (let ((init-functions (generate-code-for-init-functions tags))
        (init-classes-and-methods (generate-code-for-init-classes-and-methods exposed-classes))
        (source-info (generate-code-for-source-info tags))
        (symbol-info (generate-code-for-symbols tags)))
    (write-if-changed init-functions main-path (gethash :init_functions_inc_h app-config))
    (write-if-changed init-classes-and-methods main-path (gethash :init_classes_and_methods_inc_h app-config))
    (write-if-changed source-info main-path (gethash :source_info_inc_h app-config))
    (write-if-changed symbol-info main-path (gethash :symbols_scraped_inc_h app-config))
    (generate-tags-file (merge-pathnames #P"TAGS" (translate-logical-pathname main-path)) tags)))
